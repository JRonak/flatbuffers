/*
 *
 * Copyright 2015, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation AN/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <map>
#include <cctype>
#include "src/compiler/go_generator.h"

namespace grpc_go_generator {

// Returns string with first letter to lowerCase
grpc::string unexportName(grpc::string s) {
	if (s.size() <= 0)
		return s;
	s[0] = std::tolower(s[0]);
	return s;
}

// Generates imports for the service
void GenerateImports(grpc_generator::File *file, grpc_generator::Printer *printer,
                     std::map<grpc::string, grpc::string> vars) {
	printer->Print("//Generated by GRPC Go plugin\n");
	printer->Print(vars, "package $package$\n");
	if (file->additional_headers() != "") {
		printer->Print(file->additional_headers().c_str());
	}
	printer->Print("import (\n");
	printer->Indent();
	printer->Print(vars, "$grpc$ \"google.golang.org/grpc\"\n");
	printer->Print("$context$ \"golang.org/x/net/context\"\n");
	printer->Outdent();
	printer->Print(")\n");
	printer->Print("\n");
}

// Generates Client method signature for the service
void GenerateClientMethodSignature(const grpc_generator::Method *method, grpc_generator::Printer *printer,
                                   std::map<grpc::string, grpc::string> vars) {
	vars["methodName"] = method->name();
	vars["input"] = ", in *" + method->input_type_name();
	if (method->ClientOnlyStreaming() || method->BidiStreaming()) {
		vars["input"] = "";
	}
	vars["output"] = "* " + method->output_type_name();
	if (method->ClientOnlyStreaming() || method->BidiStreaming() || method->ServerOnlyStreaming()) {
		vars["output"] = vars["serviceName"] + "_" + vars["methodName"] + "Client" ;
	}
	printer->Print(vars, "$methodName$(ctx $context$.Context$input$, opts ...$grpc$.CallOption) ($output$, error)");
}

// Generates client API for the service
void GenerateClient(grpc_generator::Service *service, grpc_generator::Printer* printer,
                    std::map<grpc::string, grpc::string> vars) {
	// Client Interface 
	printer->Print(vars, "// Client API for $serviceName$ service\n");
	printer->Print(vars, "type $serviceName$Client interface{\n");
	printer->Indent();
	for (int i = 0; i < service->method_count(); i++) {
		GenerateClientMethodSignature(service->method(i).get(), printer, vars);
		printer->Print("\n");
	}
	printer->Outdent();
	printer->Print("\n}\n\n");

	// Client structure
	vars["servNameUnexported"] = unexportName(vars["serviceName"]);
	printer->Print(vars, "type $servNameUnexported$Client struct{\n");
	printer->Indent();
	printer->Print("cc *$grpc$.ClientConn\n");
	printer->Outdent();
	printer->Print("}\n\n");

	// NewClient
	printer->Print(vars,"func New$serviceName$Client(cc *$grpc$.ClientConn) $serviceName$Client {\n");
	printer->Indent();
	printer->Print(vars, "return &$servNameUnexported$Client{&cc}");
	printer->Outdent();
	printer->Print("}\n\n");


}


// Returns source for the service
grpc::string GenerateServiceSource(grpc_generator::File *file, grpc_generator::Service *service) {
	grpc::string out;
	auto p = file->CreatePrinter(&out);
	std::map<grpc::string, grpc::string> vars;
	vars["package"] = file->package();
	vars["grpc"] = "grpc";
	vars["context"] = "context";
	vars["serviceName"] = service->name();
	GenerateImports(file, p.get(), vars);
	return out;
}

}